# Network
随便记记
## OSI 7层模型
### 1. 物理层
md，世间万物的究极交互方式就是物理，没有物理就没有一切，懂？
- 光缆，一般都是光缆牵入网口
- 无线网口
- 深海通信电缆，北大西洋和北太平洋都是线:[参考数据](https://www.submarinecablemap.com/)

把所有的连网设备都称为节点，节点之间通过物理层进行通信，节点可以是
- 终端设备，比如你的电脑，或者服务器主机等等
- 中间设备，路由器，交换机啥的
- 当然不止这么点

第一层的数据单元是`bit`比特，为二进制，单个`byte`字节由八个`bit`组成。

每个节点可以发送或者接收比特，以前很多设备都只能发送或只能接收，像这种就叫做**单工模式**，永远只有一个人在工作，累死了。

不过现在大部分都支持**双工模式**，也就是两边一起干活，又可以接收又可以发送，两全其美。

***网线也是，双绞线，有两种模式，A类和B类，如果网线两端都是同一个类型，那么就是单通网线，反之则是交叉网线，不过现在大部分设备都支持线序识别，所以在一般情况下其实不在乎网线是什么类型的，反正都支持双工模式***

**一般故障**
- 网线寄了
- 插槽损坏，包括电路寄了
- 你没插好罢，会不会插啊

### 2. 数据链路层
这个也厉害，定义了很多规则，比如：
- 数据的传输格式
- 节点之间传输的数据大小（流量控制）
- 数据传输可以持续的时间（路线规划）
- 在数据流中的错误反馈处理措施（错误控制-检测和校正）

它同时具有两个子层：
- 介质访问控制层：`MAC, Media Access Control`子层负责分配 `mac` 地址也就是硬件标识号，在每个设备制造时就已经分配好了，所有的网络行为都会对 `mac` 进行跟踪，确保网络访问正确，就像人的指纹
- 逻辑链路控制：`LLC` 子层处理本层的数据单元的寻址以及流量控制

本层的数据单元是**帧**`frame`

每一帧包含：
- 帧头，包含源节点与目的节点的`mac`地址
- 主体，由传输的`bit`组成
- 帧尾，包括错误检测信息，检测到错误信息可能会根据配置或协议将当前错误帧丢弃，错误或被报告给上层用于校正

帧的大小通常会有一个最大值，`MTU, Maximum Transmission Unit`，巨型帧的大小超过了标准的`MTU`。

**一般故障**
- 节点会话建立失败
- 会话间歇性失败
- 帧冲突

### 3. 网络层
网络层可以借助路由器的力量，帮助我们设备访问其它网络中的设备，不在仅限与节点之间的通信了。

***路由器简单点来说就是管理存放了一系列 mac 地址以及路由信息的路由表的工具，他会根据我们访问的 ip 去找到相应的 mac 地址，也就是找到对应的节点，完成访问***

这一次的数据单元变成了**数据包**`data packet`，这个应该就没有那么陌生了，它封装了第二层的数据单元**帧**并且加上了`IP`地址信息，这部分被封装的数据也被称之为**负载**`payload`。

节点连上网，西边出太阳，此时的节点会被赋予一个协议，名为`IP, Internet Protocol`，它负责管理节点的`IP`地址，它会被路由器所使用。

`IP`地址通过协议`ARP, Address Resolution Protocol`与`mac`地址关联，`ARP`使用节点对应的`IP`地址解析`mac`地址。

**一般故障**
- 路由器寄了
- `IP`没有正确分配或配置
- 可以使用命令排错
  - `ipconfig`、`ifconfig`
  - `ping`
  - `trace`

### 4. 传输层
本层负责**数据包**的分段，也就是从**数据包**的整体角度上将其拆分成小片发送至网络。

- `TCP`将本层的数据单元称为数据包
- `UDP`将本层的数据单元称为数据报`datagram`

鼎鼎有名的两大传输控制协议：
- `TCP, Transmission Control Protocol`：
  - 面向连接
  - 优先保证数据的完整性质量
  - 显式的确认机制，与目的节点建立连接，发送数据时要求源节点与目的节点之间必须进行握手操作，确保数据完整、准确，正确到达
  - 如果数据丢失，要求进行重传
  - 确保数据包的顺序正确
- `UDP, User Datagram Protocol`：
  - 无连接协议
  - 优先速度
  - 无需握手
  - 无需等待确认，所以传输更快
  - 但数据包容易丢失并且我们无法得知丢失了什么（狗屎）
  - 一旦数据包被拆分，如果不给予序列号，`UDP`无法确保数据包的顺序正确

不论`TCP`还是`UDP`，都是从一个设备的端口将数据发送至另一台设备的特定端口，这些设备也必须拥有`IP`地址，而这些`IP`地址与端口号的组合被称为**套接字**`socket`。

**一般故障**
- 端口被禁了，看看你那该死的防火墙吧
- 还有可能是你路由器的原因，看看你那该死的路由器吧

### 5. 会话层
负责建立，维持和终止会话。

会话建立于两个网络应用之间：
- 客户端：请求信息的应用
- 服务端：提供信息的应用
- 请求与响应：双方不断的请求以及响应信息

会话根据不同场景，持续的时间可以非常短也可以非常长，过长的话有可能会导致失败。不过会话会根据采用的协议，启动各种故障解决程序，并根据所使用的应用程序，协议或者硬件，来决定会话的工作模式，**单工模式**，**半双工模式**，**全双工模式**。

**一般故障**
- 服务寄了
- 服务器配置错误
- 会话错误，断连、超时等等

### 6. 表示层
负责传输的数据的格式。字符的编解码与转换，以及数据的加密，本层确保第七层的应用可以成功消费数据并展示数据。

三种常见的数据格式化方法：
- `ASCII, American Standard Code for Information Interchange`：七位编码技术，是字符编码中使用最广泛的标准
- `EBDCIC, Extended Binary Coded Decimal Interchange Code`：补充二进制编码的十进制编码，用于大型机，`IBM`设计
- `Unicode`: 国际字符编码，用于全球，几乎容纳所有已知的字母，使用最平凡的

***加密功能：`SSL`以及`TLS`加密协议就位于这第六层，它们为网络节点提供身份认证以及数据加密功能***

**一般故障**
- 哥们驱动坏了吧

### 7. 应用层
一般开发都会接触的一层，这一层最终负责支持用户程序使用的服务，包括浏览器，QQ， Word文档。只要在后台专门执行了网络功能，那就是属于应用层的服务。

各种协议：
- `FTP, File Transfer Protocol`：文件传输协议，用于传输文件。
- `HTTP, Hypertext Transfer Protocol`：超文本传输协议，用于传输网页。
- `SSH, Secure Shell`：安全外壳协议，用于远程登录服务器。
- `SMTP, Simple Mail Transfer Protocol`：简单邮件传输协议，用于发送邮件。
- `DNS, Domain Name System`：域名系统，用于解析域名。

**一般故障**
- 应用配置有问题
- 应用有问题
- 瞎几把一顿操作坏了

## TCP
体验一下`TCP`，接下来我们使用`Rust`搭建两个服务，一个用于接收数据，一个用于发送数据。
### 搭建服务
**发送端**
```rust
use std::{io::{Read, Write}, net::TcpStream, thread::sleep, time::Duration};

fn main() {
    loop {
        let mut stream = TcpStream::connect("127.0.0.1:8080").expect("connect failed");
        stream.write("what is your name?".as_bytes()).unwrap();
        let mut buf = [0; 1024];
        stream.read(&mut buf).unwrap();
        println!("Receiver::{}", String::from_utf8_lossy(&buf));
        stream.flush().unwrap();
        sleep(Duration::from_secs(5));
    }
}
```
以上代码实现了一个不断循环发送和接收消息的TCP客户端。并且设置了一个5秒的休眠时间，模拟网络延迟。

**接收端**
```rust
use std::{io::{Read, Write}, net::{TcpListener}};

fn main() {
    let listener = TcpListener::bind("127.0.0.1:8080").expect("bind failed");
    for stream in listener.incoming() {
        match stream {
            Ok(mut stream) => {
                let mut buf = [0; 1024];
                stream.read(&mut buf).unwrap();
                println!("Sender::{}", String::from_utf8_lossy(&buf));
                stream.write("My name is ilee".as_bytes()).unwrap();
                stream.flush().unwrap();
            },
            Err(e) => {
                println!("error: {}", e);
            }
        }
    }
}
```
以上代码实现了一个`TCP`服务器，监听端口 `8080`，接收客户端连接，并接收客户端发送的数据，然后打印出来，并将字符串 **"My name is ilee"** 发送给客户端。

自己试一试运行看看结果吧

### 理解
对于读取到的数据，本身还是非常简单，并没有发送所谓的大数据。当面临大数据传输时，我们应该怎么处理？反观各种协议，我们应该怎么去读取不同的协议？就用最简单的`HTTP`协议来说，接收的数据当中第一条应该为`GET / HTTP/1.1\r\n`，我们可以根据这个来判断是HTTP协议还是其他协议。

封装其它协议也不过就是读取数据，然后根据协议规定进行解析，最后使用解析后的数据。
